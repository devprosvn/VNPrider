// Code generated by Codex prompt: VNPrider Layer 1
// DO NOT EDIT MANUALLY
package internal

import (
	"bufio"
	"os"
	"strings"
)

// P2PConfig holds peer-to-peer settings.
type P2PConfig struct {
	ListenPort     int      `toml:"listen_port"`
	BootstrapPeers []string `toml:"bootstrap_peers"`
}

// RPCConfig holds RPC server configuration.
type RPCConfig struct {
	ListenPort int `toml:"listen_port"`
}

// ValidatorConfig describes a validator.
type ValidatorConfig struct {
	ID       string `toml:"id"`
	PubKey   string `toml:"pubkey"`
	Endpoint string `toml:"endpoint"`
	Weight   int    `toml:"weight"`
}

// SecurityConfig holds security related options.
type SecurityConfig struct {
	TLSCert     string   `toml:"tls_cert_path"`
	TLSKey      string   `toml:"tls_key_path"`
	RateLimit   int      `toml:"rate_limit"`
	IPWhitelist []string `toml:"ip_whitelist"`
}

// Config aggregates all node configuration.
type Config struct {
	DataDir    string    `toml:"data_dir"`
	P2P        P2PConfig `toml:"p2p"`
	RPC        RPCConfig `toml:"rpc"`
	Validators []ValidatorConfig
	Security   SecurityConfig
}

// ParseConfig loads configuration from default files.
func ParseConfig() (*Config, error) {
	cfg := &Config{}
	if err := parseFile("config.toml", cfg); err != nil {
		return nil, err
	}
	validators := struct {
		Validators []ValidatorConfig `toml:"validator"`
	}{}
	if err := parseFile("validators.toml", &validators); err != nil {
		return nil, err
	}
	cfg.Validators = validators.Validators
	if err := parseFile("security.toml", &cfg.Security); err != nil {
		return nil, err
	}
	return cfg, nil
}

func parseFile(path string, v any) error {
	file, err := os.Open(path)
	if err != nil {
		return err
	}
	defer file.Close()
	scanner := bufio.NewScanner(file)
	m := make(map[string]string)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		parts := strings.SplitN(line, "=", 2)
		if len(parts) != 2 {
			continue
		}
		key := strings.TrimSpace(parts[0])
		val := strings.Trim(strings.TrimSpace(parts[1]), "\"")
		m[key] = val
	}
	switch c := v.(type) {
	case *Config:
		if v, ok := m["data_dir"]; ok {
			c.DataDir = v
		}
	case *SecurityConfig:
		if v, ok := m["tls_cert_path"]; ok {
			c.TLSCert = v
		}
		if v, ok := m["tls_key_path"]; ok {
			c.TLSKey = v
		}
	case *struct {
		Validators []ValidatorConfig `toml:"validator"`
	}:
		// simplified: not implemented
	}
	return scanner.Err()
}
